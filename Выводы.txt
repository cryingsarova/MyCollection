1. Сравнение ArrayList и LinkedList. 
Обычная вставка в конец работает быстрее у LinkedList, 
так как у этой коллекции быстрый доступ к первому и последнему элементу. 
Вставка состоит из 2 частей: поиск позиции вставки и сама вставка.  
2 часть выполнится быстро, так как это только смена ссылок, а вот поиск
позиции может выполняться разное количество времени, в зависимости от того,
куда нужно вставить элемент. При вставке в конец ссылка на последний элемент
уже доступна, поэтому операция происходит быстрее. 
Если сравнивать вставку в середину по индексу, то скорость заметно снижается,
так как поиск места вставки, имея индекс, происходит у ArrayList быстрее. 
Такая же ситуация и с удалением элемента. Чем дальше находится место удаления,
тем дольше будет работать LinkedList. Однако, если удалять элементы в начале 
или конце, то скорость будет превышать скорость  ArrayList.
Поэтому если часто требуется доступ по индексу или вставка элемента в середину
в больших коллекциях, то лучше использовать ArrayList, если нужно вставка в конец 
или начало, то LinkedList будет работать быстрее. 

2. Сравнение HashSet, LinkedHashSet и TreeSet
В большинстве случаев HashSet выигрывает только в операции поиска,
в остальных случаях результаты сильно варьируются в зависимости о того, 
есть ли в сете вставляемый элемент или нет, поэтому при вставке/ удалении 
разных элементов, можно получить абсолютно разные результаты. Однако время
HashSet и LinkedHashSet более стабильно при изменении условий, чем время 
операций TreeSet, которое меняется довольно сильно.
Поэтому если важен поиск, стоит использовать HashSet, он дает самый быстрый
результат.

3. Сравнение HashMap, LinkedHashMap и TreeMap
Операции вставки/ удаления имеют не очень большую разницу во времени, но
все-таки быстрее в большинстве случаев работает linkedHashMap, так как  
он располагает элементы в самом простом порядке, ни сравнивания между собой.
Но HashMap имеет самый быстрый поиск элемента, который отличается от других
коллекций в несколько раз по скорости. Поэтому если поиск элемента находится 
в приоритете, то использование HashMap будет предпочтительнее.


